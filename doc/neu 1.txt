-- ===============================================
-- 01_create_app_tables_revised.sql
-- Упрощенная структура таблиц для системы сканирования
-- (Таблицы groups, c_bands, scan_type удалены)
-- ===============================================

-- 1. Таблица `children` — Дети
-- Хранит: band_code (уникальный ID браслета), group_id (просто номер)
CREATE TABLE public.children (
  id           bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at   timestamptz DEFAULT now(),
  name         varchar NOT NULL,
  age          smallint DEFAULT 0,
  schwimmer    boolean DEFAULT FALSE,
  status       smallint DEFAULT 0,
  notes        text DEFAULT '',
  
  -- Поле для номера/ID группы (без внешнего ключа)
  group_id     smallint, 

  -- порядковый номер браслета 
  band_id    bigint
);
-- Индекс для быстрого поиска ребёнка по коду браслета
CREATE UNIQUE INDEX idx_children_band_id ON public.children USING btree(band_id);
-- Индекс для быстрого поиска ребёнка по group number
CREATE UNIQUE INDEX idx_children_group_id ON public.children USING btree(group_id);

-- 2. Таблица `scans` — Логи сканирования
-- Хранит: child_id (FK), band_code (для истории и денормализации), type (числовое поле)
CREATE TABLE public.scans (
  id           bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at   timestamptz DEFAULT now(),
  date         varchar NOT NULL, -- YYYY-MM-DD
  bus_id       smallint NULL,
  extra        jsonb NULL,
  
  -- Внешние ключи:
  user_id      bigint REFERENCES public.users(id) ON UPDATE CASCADE ON DELETE SET NULL, 
  child_id     bigint REFERENCES public.children(id) ON UPDATE CASCADE ON DELETE CASCADE, 
  
  -- Храним код браслета как обычное поле для денормализации
  band_id    bigint, 
  
  -- Используем числовое поле без внешнего ключа (1='present')
  type         smallint NOT NULL DEFAULT 1 
);
CREATE INDEX idx_scans_child_date ON public.scans(child_id, date);
CREATE INDEX idx_scans_band_created ON public.scans(band_id, created_at DESC);


-- 3. Таблица `days` — Дни программы
-- (Без изменений)
CREATE TABLE public.days (
  id           bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at   timestamptz DEFAULT now(),
  date         varchar NOT NULL UNIQUE, 
  name         varchar,
  abfahrt      time,
  ankommen     time,
  description  text
);


Вот вообще неубедительно. Короче, смотри какая ситуация реальная. Дети вышли из автобуса, мы их пересчитали, после чего они идут 300м по лесу от стоянки до аквапарка . Пять минут идут. И после этого мы должны их снова пересчитать. То есть разница между двумя событиями будет пять минут или даже меньше. Как тебе такое? Тут не нужно удалять дублирующие. Надо просто правильно их трактовать при подсчете. При подсчете мы должны устанавливать временные рамки время "от" и "до". И проверять. Выводить select distinct (child_id) по детям. Так, чтобы многократные записи сканирования не играли никакой роли (в моем понимании) И мы не знаем какая запись правильная . Скорее всего последняя.  Например Мы сосканировали ребенка, а он перешел в другой автобус. Правильная запись будет, скана последняя, там где он все-таки остался.В итоге мы должны будем учитывать все эти состояния при формировании отчета. Не каждые 5 минут и не каждый раз при сканировании мы должны лопатить всю базу. Это неправильно. Сканирование – это сырые результаты. Пользователь может 2 раза сосканировать ребенка. Если он сомневается, что все прошло, он может 3 раза сосканировать. Или даже 4. Но мы потом, когда составляем итоговый отчет, чтобы узнать, сколько у нас детей присутствовало на конкретную дату, на конкретный момент, момент он немножко растянутый по времени, то есть это какие-то временные рамки в пределах 5 минут, собственно. 2-3 минут, 5 минут, то есть эти рамки задается администратором. И чтобы мы узнали, присутствовал ли ребенок и в каком он, например, автобусе присутствовал, нам нужно правильно обработать сырые данные и отбросить ненужные результаты. Это мы будем делать при составлении отчетов. К составлению отчетов мы, наверное, придем чуть позже. Или мы уже это сделали, напомни мне

